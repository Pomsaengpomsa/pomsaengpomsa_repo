# 폼생폼사 (Perfect Pose) - 프로젝트 코드 설명서

## 📌 프로젝트 개요

**폼생폼사**는 사용자가 화면에 표시된 목표 포즈를 따라하는 인터랙티브 게임입니다.

### 주요 기능
- **마우스 모드**: 래그돌의 관절을 드래그하여 포즈 맞추기
- **카메라 모드**: 웹캠으로 실제 사용자의 포즈를 인식하여 래그돌에 반영
- **포즈 맞추기 게임**: 목표 포즈와 일치도 측정
- **벽 다가오기 게임**: 다가오는 벽의 구멍 모양에 맞춰 포즈 취하기

### 사용 기술
- **p5.js**: 캔버스 기반 그래픽 렌더링 라이브러리
- **ml5.js (PoseNet)**: 머신러닝 기반 포즈 인식 라이브러리
- **JavaScript ES6**: 클래스 기반 객체지향 프로그래밍

---

## 📁 파일 구조

```
pomsaengpomsa/
├── index.html          # 메인 HTML (UI 구조, 라이브러리 로드)
├── sketch.js           # 메인 게임 로직 (p5.js 진입점)
├── Ragdoll.js          # 래그돌 클래스 (인형 모델)
├── Pose.js             # 포즈 관리 클래스 (목표 포즈 정의)
├── CameraController.js # 웹캠 및 포즈 인식 컨트롤러
├── UI.js               # UI 렌더링 클래스
├── wall.js             # 벽 다가오기 게임 클래스
├── popup.js            # 팝업 UI 클래스
├── LocalStorageManager.js # 로컬 저장소 관리
└── assets/             # 이미지 리소스
```

---

## 🎮 핵심 코드 설명

### 1. sketch.js - 메인 게임 로직

#### 게임 상태 관리
```javascript
// 게임 상태 상수 정의
const STATE_START = 0;        // 시작 화면
const STATE_POSE_MATCH = 1;   // 포즈 맞추기 게임
const STATE_WALL_APPROACH = 2; // 벽 다가오기 게임
const STATE_CALIBRATION = 3;   // 카메라 캘리브레이션

let currentState = STATE_START;
let controlMode = 'MOUSE'; // 'MOUSE' 또는 'CAMERA'
```

**설명**: 게임은 4가지 상태로 나뉘며, `currentState` 변수로 현재 상태를 관리합니다. 상태에 따라 다른 화면과 로직이 실행됩니다.

#### p5.js 생명주기 함수
```javascript
function setup() {
  // 캔버스 생성 및 초기화
  let canvasSize = calculateCanvasSize();
  createCanvas(canvasSize.width, canvasSize.height);
  
  // 게임 객체 생성
  ragdoll = new Ragdoll(width / 2, height / 2);
  poseManager = new PoseManager();
  uiManager = new UIManager();
  wallGame = new WallGame(brickTexture);
  cameraController = new CameraController();
}

function draw() {
  // 매 프레임마다 호출 (60fps)
  // 현재 상태에 따라 다른 화면 렌더링
  if (currentState === STATE_START) {
    drawStartScreen();
  } else if (currentState === STATE_POSE_MATCH) {
    runPoseMatchGame();
  }
  // ...
}
```

**설명**: 
- `setup()`: 프로그램 시작 시 1번 실행. 캔버스와 게임 객체들을 초기화합니다.
- `draw()`: 매 프레임(1초에 60번) 호출. 현재 상태에 맞는 화면을 그립니다.

---

### 2. Ragdoll.js - 래그돌 (인형) 클래스

#### 관절 구조
```javascript
class Ragdoll {
  constructor(x, y) {
    this.x = x;  // 래그돌 중심 X좌표
    this.y = y;  // 래그돌 중심 Y좌표
    
    // 신체 부위 크기 정의
    this.headRadius = 38;
    this.upperArmLength = 68;
    this.lowerArmLength = 60;
    // ...
    
    // 관절 각도 (라디안 단위)
    this.angles = {
      neck: 0,              // 목 회전
      waist: 0,             // 허리 회전
      leftShoulder: PI,     // 왼쪽 어깨 (PI = 180도 = 왼쪽 방향)
      leftElbow: 0,         // 왼쪽 팔꿈치
      rightShoulder: 0,     // 오른쪽 어깨 (0 = 오른쪽 방향)
      rightElbow: 0,        // 오른쪽 팔꿈치
      leftHip: 0,           // 왼쪽 엉덩이
      leftKnee: 0,          // 왼쪽 무릎
      rightHip: 0,          // 오른쪽 엉덩이
      rightKnee: 0          // 오른쪽 무릎
    };
  }
}
```

**설명**: 래그돌은 10개의 관절 각도로 포즈를 표현합니다. 각도는 라디안 단위를 사용합니다.
- `PI` (약 3.14) = 180도
- `PI/2` (약 1.57) = 90도

#### 관절 위치 계산 (Forward Kinematics)
```javascript
updateJoints() {
  // 허리를 기준으로 모든 관절 위치 계산
  
  // 1. 허리 위치 (중심점)
  this.joints.waist = { x: this.x, y: this.y };
  
  // 2. 상체 위치 계산 (허리 각도 적용)
  let waistOffsetX = sin(this.angles.waist) * this.upperTorsoHeight;
  let waistOffsetY = -cos(this.angles.waist) * this.upperTorsoHeight;
  let upperTorsoX = this.joints.waist.x + waistOffsetX;
  let upperTorsoY = this.joints.waist.y + waistOffsetY;
  
  // 3. 팔 위치 계산 (어깨 각도 + 허리 각도)
  let leftElbowX = this.joints.leftShoulder.x + 
                   cos(this.angles.leftShoulder + this.angles.waist) * this.upperArmLength;
  let leftElbowY = this.joints.leftShoulder.y + 
                   sin(this.angles.leftShoulder + this.angles.waist) * this.upperArmLength;
}
```

**설명**: **Forward Kinematics(순운동학)** 방식으로 관절 위치를 계산합니다.
- 부모 관절(허리)에서 시작하여 자식 관절(어깨→팔꿈치→손) 순서로 계산
- 삼각함수 `sin`, `cos`를 사용하여 각도를 좌표로 변환
- 공식: `x = 시작점 + cos(각도) × 길이`, `y = 시작점 + sin(각도) × 길이`

#### 마우스 드래그로 관절 회전
```javascript
rotateArm(mx, my, side, isHand) {
  let shoulder = this.joints[side + 'Shoulder'];
  let elbow = this.joints[side + 'Elbow'];
  
  if (isHand) {
    // 손을 드래그하면 팔꿈치 각도 변경
    let elbowAngle = atan2(my - elbow.y, mx - elbow.x);
    this.angles[side + 'Elbow'] = elbowAngle - this.angles[side + 'Shoulder'] - this.angles.waist;
  } else {
    // 팔꿈치를 드래그하면 어깨 각도 변경
    let shoulderAngle = atan2(my - shoulder.y, mx - shoulder.x);
    this.angles[side + 'Shoulder'] = shoulderAngle - this.angles.waist;
  }
}
```

**설명**: **Inverse Kinematics(역운동학)** 개념을 단순화하여 적용합니다.
- `atan2(dy, dx)`: 두 점 사이의 각도를 계산하는 함수
- 마우스 위치에서 관절까지의 각도를 계산하여 해당 관절 각도를 업데이트

---

### 3. Pose.js - 포즈 관리 클래스

#### 포즈 정의
```javascript
class PoseManager {
  initPoses() {
    // 포즈 1: T자 포즈
    this.poses.push({
      name: "T자 포즈",
      angles: {
        neck: 0, waist: 0,
        leftShoulder: PI,      // 왼팔 왼쪽으로 (180도)
        leftElbow: 0,
        rightShoulder: 0,      // 오른팔 오른쪽으로 (0도)
        rightElbow: 0,
        leftHip: 0, leftKnee: 0,
        rightHip: 0, rightKnee: 0
      }
    });
    
    // 포즈 2: Y자 포즈 (만세)
    this.poses.push({
      name: "Y자 포즈",
      angles: {
        leftShoulder: PI * 3/4,   // 왼팔 위쪽 대각선 (135도)
        rightShoulder: -PI/4,     // 오른팔 위쪽 대각선 (-45도)
        // ...
      }
    });
  }
}
```

**설명**: 각 포즈는 10개 관절의 목표 각도를 정의합니다. 마우스 모드용 10개, 카메라 모드용 10개 포즈가 있습니다.

#### 포즈 일치도 계산
```javascript
calculateMatch(ragdollJoints, ragdollAngles) {
  // 1. 목표 포즈의 관절 위치 계산
  let targetJoints = this.calculateTargetJoints(
    this.getCurrentPose().angles,
    ragdollJoints.waist.x,
    ragdollJoints.waist.y
  );
  
  // 2. 비교할 관절 목록
  const keyJoints = ['head', 'leftElbow', 'leftHand', 'rightElbow', 'rightHand',
                     'leftKnee', 'leftFoot', 'rightKnee', 'rightFoot'];
  
  // 3. 각 관절의 거리 계산
  let totalDistance = 0;
  for (let jointName of keyJoints) {
    let actual = ragdollJoints[jointName];
    let target = targetJoints[jointName];
    let distance = dist(actual.x, actual.y, target.x, target.y);
    totalDistance += distance;
  }
  
  // 4. 평균 거리를 점수로 변환 (거리가 가까울수록 100점에 가까움)
  let avgDistance = totalDistance / keyJoints.length;
  let score = max(0, 100 - (avgDistance / 30 * 100));
  
  return score;
}
```

**설명**: 포즈 일치도는 **관절 위치 기반**으로 계산합니다.
1. 목표 포즈의 관절 위치를 계산
2. 현재 래그돌의 관절 위치와 비교
3. 9개 주요 관절의 평균 거리를 점수로 변환
4. 거리가 30픽셀 이내면 100점, 멀어질수록 점수 감소

---

### 4. CameraController.js - 웹캠 포즈 인식

#### PoseNet 초기화
```javascript
async setup() {
  // 웹캠 생성
  this.video = createCapture(VIDEO);
  this.video.size(640, 480);
  this.video.hide();
  
  // PoseNet 모델 로드 (ml5.js 사용)
  const poseNetOptions = {
    architecture: 'MobileNetV1',    // 모바일용 경량 모델
    inputResolution: 513,           // 입력 해상도 (높을수록 정확)
    detectionType: 'single',        // 한 명만 인식
    minConfidence: 0.5              // 최소 신뢰도
  };
  
  this.poseNet = ml5.poseNet(this.video, poseNetOptions, () => {
    console.log('PoseNet 모델 로드 완료!');
  });
  
  // 포즈 감지 이벤트 리스너
  this.poseNet.on('pose', (results) => {
    this.poses = results;  // 감지된 포즈 데이터 저장
  });
}
```

**설명**: **PoseNet**은 Google이 개발한 포즈 인식 AI 모델입니다.
- 웹캠 영상에서 17개의 신체 키포인트(코, 눈, 어깨, 팔꿈치 등)를 실시간 감지
- ml5.js 라이브러리를 통해 쉽게 사용 가능
- 각 키포인트는 `{x, y, score}` 형태로 반환 (score = 신뢰도)

#### 웹캠 포즈 → 래그돌 각도 변환
```javascript
getPoseAngles() {
  // 1. 벡터 계산 함수
  const getVector = (p1, p2) => {
    return { x: p2.x - p1.x, y: p2.y - p1.y };
  };
  
  // 2. 거울 모드 각도 계산 (X축 반전)
  const getMirroredAngle = (vec) => {
    return Math.atan2(vec.y, -vec.x);  // -vec.x로 좌우 반전
  };
  
  // 3. 어깨→팔꿈치 벡터로 어깨 각도 계산
  const vecRightShoulder = getVector(rightShoulder.position, rightElbow.position);
  const absRightShoulder = getMirroredAngle(vecRightShoulder);
  
  // 4. 팔꿈치→손목 벡터로 팔꿈치 각도 계산 (상대 각도)
  const vecRightElbow = getVector(rightElbow.position, rightWrist.position);
  const absRightElbow = getMirroredAngle(vecRightElbow);
  
  // 5. 상대 각도 = 자식 절대각 - 부모 절대각
  angles.rightElbow = normalize(absRightElbow - absRightShoulder);
  
  return angles;
}
```

**설명**: 웹캠에서 인식한 포즈를 래그돌 각도로 변환하는 핵심 로직입니다.

**변환 과정:**
1. **벡터 계산**: 두 관절 사이의 방향 벡터 계산
2. **거울 반전**: 웹캠은 거울처럼 좌우가 반전되므로 X축을 반전
3. **절대 각도**: `atan2(y, x)`로 벡터의 각도 계산
4. **상대 각도**: 자식 관절 각도 - 부모 관절 각도

#### 안정화 처리 (떨림 방지)
```javascript
// 스무딩 및 필터링 파라미터
this.smoothingFactor = 0.1;    // 스무딩 강도 (낮을수록 부드러움)
this.maxAngleChange = 0.3;     // 최대 변화량 제한 (약 17도)
this.deadZone = 0.04;          // 데드존 (약 2.3도)

// 스무딩 적용
for (let key in angles) {
  let angleDiff = target - this.prevAngles[key];
  
  // 1. 데드존: 작은 변화는 무시
  if (abs(angleDiff) < this.deadZone) {
    smoothedAngles[key] = this.prevAngles[key];
    continue;
  }
  
  // 2. 최대 변화량 제한: 급격한 변화 방지
  if (abs(angleDiff) > this.maxAngleChange) {
    angleDiff = this.maxAngleChange * sign(angleDiff);
  }
  
  // 3. 선형 보간: 부드러운 전환
  smoothedAngles[key] = lerp(this.prevAngles[key], target, this.smoothingFactor);
}
```

**설명**: 웹캠 인식은 노이즈가 많아 3단계 필터링으로 안정화합니다.
1. **데드존**: 2.3도 이하의 작은 변화는 무시
2. **최대 변화량**: 한 프레임에 17도 이상 변하지 않도록 제한
3. **스무딩**: 이전 값과 새 값을 10:90 비율로 섞어 부드럽게 전환

---

### 5. wall.js - 벽 다가오기 게임

#### 벽에 구멍 뚫기
```javascript
prepareWallWithHole() {
  let g = this.wallGraphics;
  
  // 1. 벽 배경 그리기 (벽돌 텍스처)
  g.image(this.brickTexture, 0, 0, 800, 600);
  
  // 2. 지우개 모드로 포즈 모양 구멍 뚫기
  g.erase();  // 이후 그리는 것은 지워짐
  this.drawPoseHole(g, currentPose.angles);
  g.noErase();
}

drawPoseHole(g, angles) {
  // 포즈 스틱 피겨를 두껍게 그려서 구멍 생성
  g.strokeWeight(38);  // 두꺼운 선
  
  // 몸통, 팔, 다리를 선으로 그림 → 해당 부분이 지워져서 구멍이 됨
  g.line(waistX, waistY, upperTorsoX, upperTorsoY);
  g.line(leftShoulderX, leftShoulderY, leftElbowX, leftElbowY);
  // ...
}
```

**설명**: p5.js의 `erase()` 기능을 사용하여 벽에 포즈 모양의 구멍을 뚫습니다.

#### 원근감 효과
```javascript
drawWall() {
  // 벽이 멀리 있을 때는 작고, 가까이 올수록 커짐
  let scaleAmount = map(this.wallScale, 0, 1, 0.1, 1.2);
  
  translate(width/2, height/2);
  scale(scaleAmount);  // 크기 조절로 원근감 표현
  
  image(this.wallGraphics, 0, 0);
}
```

**설명**: `scale()` 함수로 벽의 크기를 조절하여 다가오는 느낌을 표현합니다.

---

### 6. UI.js - 사용자 인터페이스

#### 점수 표시 및 색상
```javascript
getProgressColor(score) {
  if (score < 50) return color(255, 100, 100);  // 빨강
  if (score < 75) return color(255, 200, 100);  // 주황
  if (score < 95) return color(255, 255, 100);  // 노랑
  return color(100, 255, 150);                   // 초록
}
```

**설명**: 점수에 따라 진행 바의 색상이 변합니다.

---

## 🔧 핵심 알고리즘 요약

### 1. Forward Kinematics (순운동학)
- **용도**: 관절 각도 → 관절 위치 계산
- **원리**: 부모 관절에서 시작하여 자식 관절 순서로 위치 계산
- **공식**: `position = parent_position + (cos(angle), sin(angle)) × length`

### 2. Inverse Kinematics (역운동학) - 단순화 버전
- **용도**: 마우스 위치 → 관절 각도 계산
- **원리**: `atan2(dy, dx)`로 목표 방향의 각도 계산
- **적용**: 드래그한 관절만 회전 (전체 IK 체인 아님)

### 3. 포즈 인식 (PoseNet)
- **입력**: 웹캠 영상 (640×480)
- **출력**: 17개 키포인트의 좌표와 신뢰도
- **변환**: 키포인트 좌표 → 관절 간 벡터 → 각도

### 4. 포즈 일치도 계산
- **방식**: 관절 위치 기반 유클리드 거리
- **공식**: `score = 100 - (평균거리 / 허용거리 × 100)`

---

## 📊 게임 흐름도

```
[시작 화면]
    ↓
[모드 선택] → 마우스 모드 → [포즈 맞추기] 또는 [벽 다가오기]
    ↓
[카메라 모드]
    ↓
[캘리브레이션] (T자 포즈 3초 유지)
    ↓
[포즈 맞추기] 또는 [벽 다가오기]
```

---

## 💡 발표 시 강조할 포인트

1. **실시간 포즈 인식**: ml5.js PoseNet을 활용한 웹캠 기반 포즈 인식
2. **수학적 기반**: 삼각함수를 활용한 관절 위치 계산 (Forward/Inverse Kinematics)
3. **안정화 기술**: 노이즈 필터링, 스무딩, 데드존 적용
4. **사용자 경험**: 마우스/카메라 두 가지 입력 방식 지원
5. **게임성**: 포즈 맞추기 + 벽 다가오기 두 가지 게임 모드

---

## 🎯 Q&A 예상 질문

**Q: PoseNet은 어떻게 동작하나요?**
A: PoseNet은 CNN(합성곱 신경망) 기반 딥러닝 모델로, 이미지에서 사람의 신체 부위를 감지합니다. MobileNetV1 아키텍처를 사용하여 실시간 처리가 가능합니다.

**Q: 왜 각도를 라디안으로 사용하나요?**
A: JavaScript의 삼각함수(`sin`, `cos`, `atan2`)가 라디안 단위를 사용하기 때문입니다. `PI`(약 3.14)가 180도에 해당합니다.

**Q: 포즈 일치도는 어떻게 계산하나요?**
A: 9개 주요 관절(머리, 팔꿈치, 손, 무릎, 발)의 위치를 비교하여 평균 거리를 계산합니다. 거리가 가까울수록 높은 점수를 받습니다.

**Q: 카메라 모드에서 떨림은 어떻게 해결했나요?**
A: 3단계 필터링을 적용했습니다: (1) 작은 변화 무시(데드존), (2) 급격한 변화 제한, (3) 이전 값과 보간(스무딩).

---

*작성일: 2024년*
*개발자: 숭실대학교 디지털미디어학과 25학번 김동민, 이가영, 임소연*
